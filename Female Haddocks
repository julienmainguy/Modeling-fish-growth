library(FSA)
library(hnp)
library(nlme)
library(nlraa)
library(nlstools)
library(performance)
library(scam)

## The female haddock data (Honsey et al. 2017) can be downloaded here:

## https://datadryad.org/dataset/doi:10.5061/dryad.vb957

## This *haddock* dataset is also directly available on this *Modeling-fish-growth*
## repository in a .txt format that can be imported into R with the read.delim() 
## function. The headtail() function of "FSA" can be used to check the first and last
## three lines of this dataset containing 361 individual females

headtail(haddock)


## Honsey et al. (2017) have discarded the two smallest females from this dataset,
## so we will do the same here such that it is reduced to n = 359 and then check
## with the Summarize() function of "FSA" the descriptive statistics about the 
## ages of these females

haddock <- haddock[which(haddock$TotalLength >= 20),]

Summarize(Age ~ 1, data = haddock)


## VON BERTALANFFY GROWTH MODEL (VBGM) #########################################

## Estimate reasonable starting values for Linf, K, and t0, to be used in the 
## nonlinear regression used for the VBGM with the findGrowthStarts() function of
## "FSA". The regression curve based on these starting values in the plot produced
## should produce a good fit to the length-at-age data, which is the case here

(sv_haddock_VBGM <- findGrowthStarts(TotalLength ~ Age,
                                   data = haddock,
                                   type = "von Bertalanffy",
                                   plot = TRUE))


## Define the von Bertalanffy growth function (vB_fun) to be used in the nonlinear
## regression by using the makeGrowthfun() function of "FSA" with the argument 
## type = "von Bertalanffy")

vB_fun <- makeGrowthFun(type = "von Bertalanffy")


## Use the nls() function of "stats" (i.e., default R package) for the more precise
## estimation of Linf, K, and t0, using the vB_fun() just defined and starting values

m_haddock_VBGM <- nls(TotalLength ~ vB_fun(Age, Linf, K, t0), 
                      start = sv_haddock_VBGM,
                      data = haddock)


## Use the summary() function to get the parameter estimates while also using the
## argument correlation = TRUE from "nlstools" to also estimate their correlation

summary(m_haddock_VBGM, correlation = TRUE)


## Assess the adequacy of the VBGM by extracting the model residuals, examine
## how these are distributed with diagnostic plots, and perform a Shapiro-Wilk
## normality test with the nlsResiduals(), plot(), and test.nlsResiduals() functions
## of "nlstools"

resid_haddock_VBGM <- nlsResiduals(m_haddock_VBGM)

## Quantile-Quantile (QQ) plot of the standardized residuals (normality)

plot(resid_haddock_VBGM, which = 6)


## Histogram of the binned residuals (normality)

plot(resid_haddock_VBGM, which = 5)


## Shapiro-Wilk test on the standardized residuals, using $alternative to prevent
## the results of a second *Runs Test* regarding randomness from being printed
## (normality)

test.nlsResiduals(resid_haddock_VBGM)$alternative


## Diagnostic plot: standardized residuals vs. fitted values (homoscedasticity)  

plot(resid_haddock_VBGM, which = 2)


## Estimation of the coefficient of determination (R2) with the R2M() function of
## "nlraa", expressed here as a percentage (%). Corresponds to an unadjusted R2.

R2M(m_haddock_VBGM)$R2 * 100


## Calculate the adjusted Mean Square Error (MSE_adj) to allow comparison with
## the predictions of the alternative gamma SCAM further below. The difference 
## between the observed and predicted lengths for each of the 359 females are
## calculated and the corresponding residuals are then squared to calculate the
## residual sum of squares (RSS). The RSS is then divided by (n - P), where n is
## the sample size and P the number of df of the model, as reported with the
## logLik() function

model <- m_haddock_VBGM
data <- haddock
length <- data$TotalLength
n <- nrow(data)

pred <- predict(model, data, type = "response")
obs_pred <- data.frame(data, pred)
obs_pred_resid <- transform(obs_pred, resid = length - pred)
obs_pred_resid2 <- transform(obs_pred_resid, resid2 = resid^2)
RSS <- sum(obs_pred_resid2$resid2)

logLik <- logLik(model)
P <- attributes(logLik)$df

MSE_adj_VBGM <- RSS / (n - P)


## Predictions of the VBGM

## The central tendency (i.e., estimated mean) is first obtained with the predict()
## function using new data (nd_haddock) with small age increment units for the
## production of the related plot of the growth curve.To avoid extrapolation,
## the predictions are only produced for the range of observed ages in the sample

nd <- data.frame(Age = seq(min(haddock$Age), max(haddock$Age), by = 0.1))

estimate <- predict(m_haddock_VBGM, nd)


## As currently the nls() function cannot estimate a SE and thus a confidence
## interval, a commonly-used approach to circumvent this situation is to instead
## use a bootstrapped 95% CI with the nonparametric bootstrapping approach that
## is implemented in "nlstools" with the nlsBoot() function. This function will
## use by default 999 resampling iterations with no underlying assumptions, solely
## using the observed data of the considered model, and then use the 2.5th and 
## 97.5th percentiles of the resulting distribution for the estimation of the 
## bootstrapped 95% CI. To obtain the lower and upper bootstrapped 95% CI limits,
## the predict() function needs to be applied to the bootstrapped results with
## the von Bertalanffy function of "FSA" and for the same range of observed ages,
## as was done above

boot_haddock_VBGM <- nlsBoot(m_haddock_VBGM) 

vB_fun <- makeGrowthFun(type = "von Bertalanffy") ## same as used above

CI_haddock_VBGM <- data.frame(predict(boot_haddock_VBGM,
                                      vB_fun,
                                      t = seq(min(haddock$Age),
                                              max(haddock$Age), 
                                              by = 0.1)))


## Data frame of the predicted values for the mean and bootstrapped 95% CI limits

age <- nd$Age
lower_ci <- CI_haddock_VBGM$X95..LCI
upper_ci <- CI_haddock_VBGM$X95..UCI

pred_haddock_VBGM <- data.frame(age, estimate, lower_ci, upper_ci)


## SHAPE CONSTRAINED ADDITIVE MODEL (SCAM) #####################################

## The scam() function of "scam" is used to model the length-at-age relationship
## in a single step. For this, it uses a smooth function, s(), with mixed constraints
## requiring that the predicted curve to be monotonously-increasing (mi) and
## also concave (cv), with the specifically-designed P-splines for this being
## applied with the argument bs = "micv". A gamma distribution with a log link
## was systematically fitted, which does not assume normality nor homoscedasticity,
## by modeling the variance to be proportional to the mean, thus reflecting the
## increasing variation in length with age. The "efs" optimizer is used instead of
## the default one, but the latter should produce similar results when only fixed
## effects are used

m_haddock_SCAM <- scam(TotalLength ~ s(Age, bs = "micv"),
                       family = Gamma(link = "log"),
                       optimizer = "efs",
                       data = haddock)

summary(m_haddock_SCAM)


## Using the scam.check() function allows to confirm that the model has converged
## and also produces four diagnostic plots: (i) QQ plot, (ii) Residuals vs. linear
## predictor, (iii) Histogram of residuals, and (iv) Response vs. Fitted values. 
## These four plots are especially useful when a Gaussian distribution is used, 
## with (i) and (iii) looking at whether the deviance residuals are sufficiently
## normally distributed, and (ii) whether the residuals are sufficiently homoscedastic. 
## For non-Gaussian distributions, like the gamma distribution with a log link, 
## the assumption of normality does not need to be respected, nor the one about
## homoscedasticity. Therefore, the QQ plot is the most useful to determine whether
## the Gaussian or gamma distribution is sufficiently respected (i.e., the residuals
## should be uniformly distributed along the theoretical quantiles). It is used
## here mainly to check whether the model has correctly converged

scam.check(m_haddock_SCAM)


## QQ plots can be produced with the qq.scam() function to more closely examine
## the behaviour of the deviance residuals. Using the argument rep = 5000 will 
## allow perform 5000 simulations that will then be used to add a confidence band
## in which most of the residuals should be found for a well-fitting model, here at
## at level of confidence of 95% as indicated by the argument level = 0.95. Lastly,
## the argument pch = 20 indicate to use a given type of symbol in the QQ plot to
## illustrate the residuals

qq.scam(m_haddock_SCAM, rep = 1000, level = 0.95, pch = 20)


## Estimate the in-sample predictive performance with the deviance explained (D2)
## and its adjusted version (D2_adj), as detailed in the main text

model <- m_haddock_SCAM

D2 <- 100 * (1 - model$deviance / model$null.deviance)
logLik <- logLik(model)
P <- attributes(logLik)$df
n <- summary(model)$n
D2_adj <- 100 - ((n - 1) / (n - P) * (100 - D2))
cbind(D2, D2_adj)


## Calculate the MSE_adj of the gamma SCAM

model <- m_haddock_SCAM
data <- haddock
length <- data$TotalLength
n <- nrow(data)

pred <- predict(model, data, type = "response")
obs_pred <- data.frame(data, pred)
obs_pred_resid <- transform(obs_pred, resid = length - pred)
obs_pred_resid2 <- transform(obs_pred_resid, resid2 = resid^2)
RSS <- sum(obs_pred_resid2$resid2)

logLik <- logLik(model)
P <- attributes(logLik)$df

MSE_adj_SCAM <- RSS / (n - P)


## Percentage of improvement (i.e., reduction) in MSE_adj from VBGM to SCAM

(MSE_adj_VBGM - MSE_adj_SCAM) / MSE_adj_VBGM * 100


## Predictions of the gamma SCAM

model <- m_haddock_SCAM
 
nd <- data.frame(Age = seq(min(haddock$Age), max(haddock$Age), by = 0.1))
 
fitted <- predict(model, nd, type = "link", se.fit = TRUE)
estimate <- exp(fitted$fit)
lower_ci <- exp(fitted$fit - 1.96 * fitted$se.fit)
upper_ci <- exp(fitted$fit + 1.96 * fitted$se.fit)
 
age <- nd$Age
pred_haddock_SCAM <- data.frame(age, estimate, lower_ci, upper_ci)
